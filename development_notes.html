<!DOCTYPE html>
<html lang="en">
<head>
    <title>COLD (Controlled Object List and Datum (Concept))</title>
    <link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="https://caltechlibrary.github.io/css/site.css">
</head>
<body>
<header>
<a href="http://library.caltech.edu" title="link to Caltech Library Homepage"><img src="https://caltechlibrary.github.io/assets/liblogo.gif" alt="Caltech Library logo"></a>
</header>
<nav>
<ul>
    <li><a href="/">Home</a></li>
    <li><a href="index.html">README</a></li>
    <li><a href="LICENSE">LICENSE</a></li>
    <li><a href="INSTALL.html">INSTALL</a></li>
    <li><a href="user_manual.html">User Manual</a></li>
    <li><a href="about.html">About</a></li>
    <li><a href="https://github.com/caltechlibrary/cold">GitHub</a></li>
</ul>
</nav>

<section>
<h1 id="development-notes">Development Notes</h1>
<h2 id="application-layout-and-structure">Application layout and
structure</h2>
<p>The primary task of the COLD UI is to provide a means of curating our
list of objects and vocabularies. Each list is held in a dataset
collection. Datasetd is used to provide a JSON API to curate the
individual objects for each of our collections. TypeScript running via
Deno is providing the middleware to tie our JSON API with our static
content. The front end web server (i.e. Apache 2) provides integration
with Shibboleth provides single sign on and access control.</p>
<p>I am relying on feeds.library.caltech.edu to provide the public
facing API. Data is transfered to feeds via scripts run on a schedule or
“on demand” via a Deno task running.</p>
<h2 id="the-go-dataset-and-models-package">The Go dataset and models
package</h2>
<p>The latest evolution of dataset includes support for restricting
collections to specific data models. A model is base on data types that
easily map from HTML 5 form elements to SQL data types. Additionally
there are types associated with library and archives such as support for
ISNI, ORCID and ROR. Dataset still supports adhoc JSON object storage if
that is needed.</p>
<p>The data models ar enforced only via the datasetd service. Eventually
model support will be unforced for the dataset cli.</p>
<p>Data models are expressed in YAML and are shared between dataset and
the model YAML used by Newt. Both use the same models package written in
Go. The models package procides a means of define more types as well as
adding renders. It is being developed in parallel with Newt, Dataset and
the COLD where the latter is providing a real world use case to test the
approach.</p>
<p>The public API isn’t part of COLD directly. COLD is for curating
object lists but it does export those objects to
feeds.library.caltech.edu which then provides the public API. Content is
exported in JSON, YAML and CSV formats as needed by Caltech Library
systems and services.</p>
<h2 id="reports">Reports</h2>
<p>Reports are implemented either as dataset SQL queries or other
scripts. Since reports can be slow to run and consume reports are
implemented using a task queue. Reports are requests, the results
rendered and then a link is created and available on the completed
reports page. A link is also emailed to the requestor.</p>
<p>Reports are implemented as a tasks. A task is defined in Deno’s JSON
file. A Deno task isn’t limited to TypeScript or JavaScript. It can all
out to run other programs which in turn can be written in Bash, Python
or be a simple dsquery. Limitting external execution of defined tasks is
important for the security of the system and host machine. This is why
the tasks are predefined. Adhoc reports are not implemented in COLD.</p>
<h2 id="data-enhancement">Data enhancement</h2>
<p>The content curated in cold is enhanced from external source. This is
done via scheduled tasks. An example is biographical and other
information published in the Caltech Directory is harvested and merged
into our Caltech People objects.</p>
<p>External data sources:</p>
<ul>
<li>Caltech Directory</li>
<li>orcid.org</li>
<li>ror.org</li>
</ul>
<h2 id="reports-1">Reports</h2>
<p>Reports are often needed for managing library data and systems.
COLD’s focus is on managing lists and data but can also serve as a
reports request hub.</p>
<p>Many of the reports require aggrestion across data sources and often
these will take too long or require too many resources to be run
directly on our applicaiton server. That suggests what should run on the
applications server is a simple reports request management interface.
The suggestions the following requirements.</p>
<ul>
<li>A way to make a request for a report</li>
<li>A means of indicating a report status (e.g. requested or scheduled,
processing, available or problem indicator)</li>
<li>A means of notifying the requestor(s) when report is available</li>
<li>A means of purging old reports for the reports status list</li>
</ul>
<p>These features can be implemented as a simple queue. The metadata
needed to manage a report requests and their life cycle are as
follows.</p>
<ul>
<li>name of report</li>
<li>any additional options needed by the report program</li>
<li>an email address(es) to contact when the report is ready</li>
<li>current status of the report (e.g. requested, processing, available,
problem)</li>
<li>a link to where the report can be “picked up”</li>
<li>the report’s content type, (e.g. application/json, application/yaml,
application/x-sqlite3, text/csv, text/plain, text/x-markdown)</li>
<li>the date the report was requested</li>
<li>the updated (when the status last changed)</li>
</ul>
<p>The user interface would consist of a simple web form to request a
predefined set up reports and a list of reports available, processing,
requested or scheduled.</p>
<p>The reports themselves can be implemented as commmand line programs
in a language of your choice. The report runner will be responsible for
checking the queue and updating the queue. The report would be
responsible for notification (e.g. is there is an email list then send
out an email with the report link). In princle since our GitHub actions
are accessible via the GitHub APIs a report could be implemented as a
GitHub action.</p>
<p>The advantage of this approach is that it avoids the problems of slow
running or resource intensive reports running directly on the
application server. COLD just manages the report queue.</p>
<p>Advantage of narrowing the COLD’s report to managing a report queue
is that it separates the concerns (e.g. resource management, security,
report access).</p>
<p>For the report management interface to be useful you do need a report
runner. The report runner would be responsible for checking the report
queue, updating status of the report queue and making the report
request.</p>
<p>NOTE: the runner doesn’t need to run on your apps server. It just
needs access to the queue.</p>
<p>A report would need to implement a few things.</p>
<ul>
<li>accept the metadata held in the report queue</li>
<li>storing the report result</li>
<li>return a result needed by the runner to update the report queue
(success, failure and the link to the result)</li>
</ul>
<p>QUESTION: Should the report be responsible for notification or the
runner?</p>
<p>The individual reports can be implemented as a script (e.g. Bash), a
program (e.g. something in Python) or even externally (e.g. GitHub
action). The interface for the report would be to recieve a JSON
expression from standard input and return a JSON expression via standard
output to the runner along with an error code (i.e. zero no problem,
non-zero there was a problem). The report script or program would use a
link to indicate where the report could be picked up and be responsible
to placing content in a storage location accessbile via the link.</p>
<p>Report status:</p>
<dl>
<dt>requested</dt>
<dd>
An entry that a request has been made and is waiting to be serviced
</dd>
<dt>processing</dt>
<dd>
The report reqest is being serviced but is not yet available
</dd>
<dt>available</dt>
<dd>
A report result is available and the link indicates where you can pick
it up
</dd>
<dt>problem</dt>
<dd>
The report request could not be completed and the link indicates where
the details can be found about what when wrong.
</dd>
</dl>
<p>Report identifiers:</p>
<p>There are two basic report types. Those which are run on a schedule
(e.g. recent grant report from thesis or creators report from authors)
and those which are requested then run. For the scheduled reports the
identifier would be in the reports’ unqiue name. For requested reports
another mechanism maybe required. A good canidate for the identifier
would be UUID v5. Since the report script or program is responsible for
storing the results it would also be responsble for versioning the
stored results if needed. By separating the ID from the report instance
it is left to the report what the name of the stored result is while
still being able to map a request to that link’s instance.</p>
<p>Reports can be of different content types. Most reports we generate
manually today are either CSV, tab demlimited or Excel files. By
allowing reports to have different content types we also allow for the
report to be provided in a relavant type. E.g. a report could be
generated as a PDF or even an SQLite3 database.</p>
<h3 id="exploring-implementation-ideas">Exploring implementation
ideas</h3>
<p>I’m thinking about the report runner does not need to run on our apps
server. The runner needs two know what reports are available and if they
are scheduled or not. It needs to be able to interact with COLD’s report
queue. If COLD’s reports dataset collection is implemented with Postgres
storage then Postgres can provide the record management of a report’s
state. This could simplify implementation while requiring additional
initial deployment setup (e.g. setting up Postgres on the apps server to
be accessible from the data processing machine).</p>
<p>Making the assumption that reports are run on our data processing
machine then we remove the resource consumption to generate the report
the apps server to the data processing server. E.g. the data processing
server could be the some one we use to generate other static resources
like feeds.</p>
<p>A runner could be implemented either as a daemon or cronjob.</p>
<p>The cronjob approach is nice because it avoids implementing a
scheduler in the report runner.</p>
<p>If it was daemon we could poll the queue periodically by sleeping
between poll requests. When a request is recieved it updates the request
status then starts executing the report. A simple runner could take the
requests sequentially based on requested timestamp with a status of
requested. A transaction could be used to make the reading of the next
request and setting it to processing atomic. When no requested reports
are available the daemon would sleep for a period of time before
checking again otherwise it would fetch the next request and begin
processing.</p>
<p>If the runner supports concurency then the queue can be managed more
effectively and avoid long running reports from hogging the system.</p>
<p>Scheduled reports can be implemented by injecting a request into the
queue via a cronjob. This would allow the daemon remain single without a
scheduler.</p>
<p>Advantages to defering report processing to another machine is that
we can include databases that we don’t want to host or be available
directly apps server (e.g. student data on apps server should be
minimized). The apps server doesn’t have to know what reports are
available, it would only manage the requests and provide a UI to make a
request. Regularly scheduled reports would be listed in the available
reports list but wouldn’t have to be included in the UI decluttering the
list of reports available to request. Report distribution wouldn’t
necessarily have to be on apps either. Reports could be pushed into
other storage (e.g. G-Drive, Box, etc) leaving only the link information
on the apps server.</p>
</section>

<footer>
<span>&copy; 2022 <a href="https://www.library.caltech.edu/copyright">Caltech Library</a></span>
<address>1200 E California Blvd, Mail Code 1-32, Pasadena, CA 91125-3200</address>
<span><a href="mailto:library@caltech.edu">Email Us</a></span>
<span>Phone: <a href="tel:+1-626-395-3405">(626)395-3405</a></span>
</footer>
</body>
</html>
