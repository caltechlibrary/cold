cold - (c)ontrolled (o)bject (l)ists and (d)atum
================================================

This repository implements a service to maintain a controlled list of objects and vocabularies used at Caltech Library for people, organizations and funders. It is built from data modeled in PostgreSQL, a JSON API provided by PostgREST and a template engine provided by Pandoc (in server mode).  This leaves the backend development in Postgres SQL and the front end development in HTML, CSS and JavaScript using all the current (2023) capabilities of your common popular browsers (e.g. Firefox, Chrome, Edge and Safari).

The "stack" is based on the primose of cooprative microservices using "off the shelf" Open Source software (e.g. Apache2+Shibboleth, Postgres, PostgREST, Pandoc) and a thin layer of UI work running in your web browser.

Overview
--------

Caltech Library maintains a list of people, groups and funders and their related pids. This started being managed in Google Sheets, then in CSV files. The number of objects involved has increased. It makes sense to provide a more robust implementation allowing for easier curation of objects. The objects currently are relatively flat.  Here's an example JSON object representing R. S. Doiel showing the internal identifier named "cl_people_id", name object, email, orcid and Caltech affiliation is shown both via a boolean field and a ROR.

~~~json
{
    "cl_people_id": "Doiel-R-S",
    "family_name": "Doiel",
    "given_name": "Robert",
    "orcid": "0000-0003-0900-6903",
    "authors_id": "Doiel-R-S",
    "directory_id": "rsdoiel",
    "caltech": true,
    "status": "Active",
    "directory_person_type": "Staff",
    "division": "Libraries Group",
    "updated": "2022-03-09"
    "ror": "https://ror.org/05dxps055"
} 
~~~

A group object for Caltech Library is relatively flat.

~~~json
{
    "cl_group_id": "Caltech-Library",
    "name": "Caltech Library",
    "alternative": [ "Caltech Library System", "Library System Papers and Publications" ],
    "updated": "2023-07-21 00:08:00",
    "created": "2023-07-21",
    "email": "library@caltech.edu",
    "description": "Caltech Library serves teaching, research, and academic needs of its students, faculty, and staff of Caltech.",
    "start": "1965",
    "start_is_approx": true,
    "activity": "active",
    "end": "",
    "end_is_approx": false,
    "website": "https://library.caltech.edu",
    "pi": "",
    "parent": "",
    "prefix": "",
    "grid": "",
    "isni": "",
    "ringold": "",
    "viaf": "",
    "ror": "https://ror.org/05dxps055"
}
~~~

Both these records can easily be represented in a Postgres table and the SQL to bookstrap that can be generated by Newt.

A simple YAML based model description used to by Newt to generate the SQL too bootstrap Cold's models. Further improvement to the modules, views and functions can then be maintained in the SQL sources generated. In addition to providing the outline of the models the YAML file also defines the route handling (the path mapping of urls) that Newt uses to provide access to Postgres via PostgREST as well as optionally templating the result via Pandoc service.

A Newt description of the person model would like the following. The SQL bootstrap is generated automatically by Newt using the option `-pg-models`.

~~~yaml
models:
- model: cl_people
- var:
  cl_people_id: String
  family_name: String
  given_name: String
  orcid: ORCID
  author_id: String
  directory_id: String
  caltech: Boolean
  status: Boolean
  direcotry_person_type: String
  division: String
  updated: Date 2006-01-02
  ror: ROR
- model: cl_group
- var:
  cl_group_id: String Primary Key
  name: String
  alternative: Array String
  updated: Timestamp
  # Date group was added to Group List
  date: Date 2006-01-02
  email: EMail
  description: Text
  start: String
  # approx_starts indicates if the "start" is an approximate (true) or exact (false)
  approx_start: Boolean
  # activity is a string value holding either "active" or "inactive"  
  activity: String
  end: String
  # approx_end indicates if the "start" is an approximate (true) or exact (false)
  approx_end: Boolean
  website: Url
  pi: String
  parent: String
  # prefix holds the DOI prefix associated with the group
  prefix: String
  grid: String
  isni: ISNI
  ringold: String
  viaf: String
  ror: ROR
~~~

Newt takes a declarative approach to defining the backend, middleware data flow and generate resulting web content.

Approach Details
----------------

- **cold** is built using Newt. 
- Newt is used to generate the basic SQL models deployed in Postgres
- PostgREST is used to provide a JSON API for managing objects and controlled vocabularies
- Pandoc server is used to render JSON in a human friendly UI
- Newt orchestrates the conversation between the web browser and the backend
    - Newt gets a request from a web browser
    - Newt talks to PostgREST
    - Newt talks to Pandoc (if needed)
    - Newt Responds to the browser

An important distinction to note is Newt has zero concept of users or access control (unless you build that
into your database setup, views and functions). **cold** as is typical at Caltech Library uses our single
sign-on system, Shibboleth, to hand user authentication. Apache2 uses the user data provided by Shibboelth
along with an access control list to control access to Newt (which listens via localhost only).  

**cold** like current Newt based projects assumes a shallow model of access crontrol.  If you need more then
you need to build that from within Postgres itself.

Pandoc as a template engine has no concept of session or who is accessing it. It just gets a request and
if the the request is valid processes the result through the included JSON encoded data and pandoc template.
Pandoc un server mode doesn't read from disk after launch, doesn't procude logs and does not maintain state.


**cold**'s End Points
---------------------

JSON API is provided by PostgREST. The following end point descriptions support the GET method.

`/`
: A description of PostgREST information

`/cold/version`
: Returns the version number of the service

`/cold/people`
: Returns a list of "cl_people_id" managed by *cold* 

`/cold/people/{CL_PEOPLE_ID}`
: For a GET returns a people object, a PUT will create the people object, POST will replace the people object and DELETE will remove the people object

`/cold/group`
: Returns a list of "cl_group_id" managed by *cold*

`/cold/group/{CL_GROUP_ID}`
: For a GET returns a group object, a PUT will create the group object, POST will replace the group object and DELETE will remove the group object

Crosswalks
----------

A cross walk lets you put in a collection name (e.g. people, group), a field name and a value and it returns a list of matching
records.

`/cold/crosswalk/people/{IDENTIFIER_NAME}/{IDENTIFIER_VALUE}`
: Returns a list of "cl_people_id" assocated with that identifier

`/cold/crosswalk/group/{IDENTIFIER_NAME}/{IDENTIFIER_VALUE}`
: Returns a list of "cl_group__id" assocated with that identifier

*cold* takes a REST approach to updates for managed objects.  PUT will create a new object, POST will update it, GET will retrieve it and DELETE will remove it.

Vocabularies
------------

*cold* also supports end points for stable vocabularies mapping an indentifier to a normalized name. These are set at compile time because they are so slow changing. 

`/cold/subject`
: Returns a list of all the subject ids (codes)

`/cold/subject/{SUBJECT_ID}`
: Returns the normalized text string for that subject id

`/cold/issn`
: Returns a list of issn that are mapped to a publisher name

`/cold/issn/{ISSN}`
: Returns the normalized publisher name for that ISSN

`/cold/doi-prefix`
: Returns a list of DOI prefixes that map to a normalize name

`/cold/doi-prefix/{DOI_PREFIX}`
: Returns the normalized publisher name for that DOI prefix

Manage interface
----------------

The management inteface is avialable at `/app/dashboard.html` path. This provides a dashboard which then interacts with the JSON side of the service to update content. The manage interface is built from Web Components and requires JavaScript to be enabled in the browser.

Widgets
-------

Widgets are implementations of one or more Web Components. They provide the user interface for humans to manage and view the objects. While **cold** can directly host these it is equally possible to integrate the static components into another system, web service or web site. The public facing web service needs to control access to **cold** and the static content does not contain anything that is priviliged. The Widgets can be loaded indepentently in the page using the following end points.

`/widgets/person.js`
: This JavaScript file provides a display and input set of web components for our Person Object. Markup example `<person-display honorific="Mr." given="R. S." family="Doiel" lineage="" orcid="0000-0003-0900-6903"></person-display>` and `<person-input honorific="Mr." given="R. S." family="Doiel" lineage="" orcid="0000-0003-0900-6903"></person-input>`

`/widgets/group.js`
: This JavaScript file provides a display and input set of web components for our Markup example `<group-display name="GALCIT" ror=""></group-display>` and `<group-input  name="GALCIT" ror="" label=""></group-input>`

`/widgets/vocabulary.js`
: This JavaScript file provides a identifier/name web component suitable for displaying subjects, issn/publisher info and doi-prefix/publisher info.


Requirements
------------

- PostgreSQL >= 14
- PostgREST >= 11
- Pandoc >= 3
- Newt >= 0.0.3
- To build the UI and compile the assets needed by **cold**
  - GNU Make
  - [Pandoc](https://pandoc.org) (to build UI)
  - A text editor (e.g. Zed, VSCode, micro, nano, vi, emacs ...)
- A front end web server with SSO or Basic Auth support
- A web browser with JavaScript support 

Recommended
-----------

Most package managers running on various flavors of Unix (e.g. macOS, Linux) do not provide Pandoc 3 or PostgREST at this time (2023-12).  There is a good chance you will need to build this from source. 

Pandoc and PostgREST are Haskell programs (i.e. they are written in Haskell programming langauge and use it's tool chain).  I recomment installing GHCup first then download and build Pandoc and PostgREST.  GHCup provides a reliable Haskell development environment.

1. Install Haskell via [ghcup](https://www.haskell.org/ghcup/)
2. See [Pandoc](https://pandoc.org/installing.html#quick-cabal-method) and follow instructions to compile Pandoc 3
3. See [https://postgrest.org/en/stable/install.html#building-from-source]) and following instructions to compile PostgREST 11

### A note about macOS, Postgres and PostgREST

I have found the easiest most reliable way to get Postgres and PostgREST up and running on macOS is via [Postgres APP](https://postgres.app).

If you take this route you want to install the version with the heading [Postgres.app with all currently supported versions (Universal/Intel)](https://postgresapp.com/downloads.html). This will insure you have the necessary libraries install that [PostgREST](https://postgrest.org) needs when compiling from source (i.e. `libpg`). 

